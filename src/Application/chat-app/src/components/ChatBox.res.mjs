// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bytes from "rescript/lib/es6/bytes.js";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as ChatInput from "./ChatInput.res.mjs";
import * as Js_option from "rescript/lib/es6/js_option.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as ChatEncryption from "../bindings/ChatEncryption.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function ChatBox(props) {
  var currentUser = props.currentUser;
  var match = React.useState(function () {
        return [];
      });
  var setMessages = match[1];
  var messages = match[0];
  var match$1 = React.useState(function () {
        
      });
  var setSocket = match$1[1];
  var socket = match$1[0];
  var match$2 = React.useState(function () {
        return [];
      });
  var setAvailableUsers = match$2[1];
  var availableUsers = match$2[0];
  var match$3 = React.useState(function () {
        
      });
  var setSelectedUser = match$3[1];
  var selectedUser = match$3[0];
  var match$4 = React.useState(function () {
        return {};
      });
  var setUnreadMessages = match$4[1];
  var unreadMessages = match$4[0];
  var privKeyRef = React.useRef("");
  var sharedKeysRef = React.useRef({});
  var performKeyExchange = function (recipient, theirPubKey, ws) {
    return ChatEncryption.generate_and_encrypt_shared_key(theirPubKey).then(function (response) {
                console.log("Generated shared key : ");
                console.log(response.sharedKey);
                var keyExchangeMessage = {};
                keyExchangeMessage["type"] = "keyExchange";
                keyExchangeMessage["from"] = currentUser;
                keyExchangeMessage["to"] = recipient;
                keyExchangeMessage["encryptedSharedKey"] = response.encryptedSharedKey;
                console.log("Shared encrypted shared key");
                ws.send(JSON.stringify(keyExchangeMessage));
                var newSharedKeys = Js_dict.fromArray(Js_dict.entries(sharedKeysRef.current));
                newSharedKeys[recipient] = Bytes.to_string(response.sharedKey);
                sharedKeysRef.current = newSharedKeys;
                return Promise.resolve();
              });
  };
  var getPublicKey = function (username) {
    if (socket !== undefined) {
      var publicKeyRequest = {};
      publicKeyRequest["type"] = "publicKeyRequest";
      publicKeyRequest["from"] = currentUser;
      publicKeyRequest["to"] = username;
      Caml_option.valFromOption(socket).send(JSON.stringify(publicKeyRequest));
      return ;
    }
    console.log("WebSocket not connected");
  };
  var formatTimestamp = function (isoString) {
    var date = new Date(isoString);
    var hours = String(date.getHours() | 0).length === 1 ? "0" + String(date.getHours() | 0) : String(date.getHours() | 0);
    var minutes = String(date.getMinutes() | 0).length === 1 ? "0" + String(date.getMinutes() | 0) : String(date.getMinutes() | 0);
    return hours + ":" + minutes;
  };
  React.useEffect((function () {
          if (socket === undefined) {
            var ws = new WebSocket("ws://localhost:8080");
            ws.onopen = (function () {
                console.log("Connected to WebSocket");
                console.log("Generating keypair");
                var match = ChatEncryption.generate_keypair_for_new_user();
                console.log("Public and private key generated");
                privKeyRef.current = match[1];
                var loginData = {};
                loginData["type"] = "login";
                loginData["username"] = currentUser;
                loginData["pubKey"] = match[0];
                ws.send(JSON.stringify(loginData));
                setSocket(function (param) {
                      return Caml_option.some(ws);
                    });
              });
            ws.onmessage = (function ($$event) {
                try {
                  var message = JSON.parse($$event.data);
                  var messageObj = Belt_Option.getExn(Js_json.decodeObject(message));
                  var messageType = Belt_Option.flatMap(Js_dict.get(messageObj, "type"), Js_json.decodeString);
                  if (messageType === undefined) {
                    return ;
                  }
                  switch (messageType) {
                    case "keyExchange" :
                        console.log("Received key exchange request");
                        var from = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "from"), Js_json.decodeString), "Unknown");
                        var encryptedSharedKey = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "encryptedSharedKey"), Js_json.decodeString), "");
                        var sharedKey = ChatEncryption.decrypt_recieved_shared_key(privKeyRef.current, encryptedSharedKey);
                        console.log("Decrypted shared key : ");
                        console.log(sharedKey);
                        var newSharedKeys = Js_dict.fromArray(Js_dict.entries(sharedKeysRef.current));
                        newSharedKeys[from] = Bytes.to_string(sharedKey);
                        sharedKeysRef.current = newSharedKeys;
                        return ;
                    case "privateChat" :
                        var encryptedMessage = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "message"), Js_json.decodeString), "");
                        console.log("Encrypted Message Recieved : " + encryptedMessage);
                        var nonce = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "nonce"), Js_json.decodeString), "");
                        var sender = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "from"), Js_json.decodeString), "Unknown");
                        var sharedKey$1 = Belt_Option.getExn(Js_dict.get(sharedKeysRef.current, sender));
                        ChatEncryption.decrypt_message(sharedKey$1, nonce, encryptedMessage).then(function (decryptedMessage) {
                              console.log("Message successfully decrypted : " + Bytes.to_string(decryptedMessage));
                              setUnreadMessages(function (prevUnread) {
                                    var newUnreadMessages = Js_dict.fromArray(Js_dict.entries(prevUnread));
                                    var count = Js_dict.get(newUnreadMessages, sender);
                                    var currentUnreadCount = count !== undefined ? count + 1 | 0 : 1;
                                    newUnreadMessages[sender] = currentUnreadCount;
                                    return newUnreadMessages;
                                  });
                              var newMessage_from = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "from"), Js_json.decodeString), "Unknown");
                              var newMessage_to_ = Belt_Option.flatMap(Js_dict.get(messageObj, "to"), Js_json.decodeString);
                              var newMessage_message = Bytes.to_string(decryptedMessage);
                              var newMessage_timestamp = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "timestamp"), Js_json.decodeString), "");
                              var newMessage = {
                                msg_type: "PrivateChat",
                                from: newMessage_from,
                                to_: newMessage_to_,
                                message: newMessage_message,
                                timestamp: newMessage_timestamp
                              };
                              setMessages(function (prev) {
                                    return Belt_Array.concat(prev, [newMessage]);
                                  });
                              return Promise.resolve();
                            });
                        return ;
                    case "publicKeyRequestResponse" :
                        var theirPubKey = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "publicKeyInfo"), Js_json.decodeString), "");
                        var username = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(messageObj, "from"), Js_json.decodeString), "Unknown");
                        console.log("Received public key of user : " + username);
                        performKeyExchange(username, theirPubKey, ws).then(function () {
                              return Promise.resolve();
                            });
                        return ;
                    case "userList" :
                        var obj = Js_json.decodeObject(message);
                        var users;
                        if (obj !== undefined) {
                          var usersJson = Js_dict.get(obj, "users");
                          if (usersJson !== undefined) {
                            var arr = Js_json.decodeArray(usersJson);
                            users = arr !== undefined ? Belt_SetString.toArray(Belt_SetString.remove(Belt_SetString.fromArray(Belt_Array.keepMap(arr, Js_json.decodeString)), currentUser)) : [];
                          } else {
                            users = [];
                          }
                        } else {
                          users = [];
                        }
                        return setAvailableUsers(function (param) {
                                    return users;
                                  });
                    default:
                      return ;
                  }
                }
                catch (raw_err){
                  var err = Caml_js_exceptions.internalToOCamlException(raw_err);
                  console.log("Error parsing message");
                  console.log(err);
                  return ;
                }
              });
            ws.onclose = (function () {
                console.log("WebSocket connection closed xyz");
                setSocket(function (param) {
                      
                    });
              });
          }
          return (function () {
                    if (socket !== undefined) {
                      Caml_option.valFromOption(socket).onclose = (function () {
                          
                        });
                      return setSocket(function (param) {
                                  
                                });
                    }
                    
                  });
        }), []);
  var handleSendMessage = function (message) {
    var timestamp = new Date().toISOString();
    var messageData = {};
    if (selectedUser !== undefined) {
      messageData["type"] = "privateChat";
      messageData["to"] = selectedUser;
    } else {
      console.log("No user selected");
    }
    messageData["from"] = currentUser;
    messageData["timestamp"] = timestamp;
    var sharedKey = sharedKeysRef.current[Js_option.getExn(selectedUser)];
    ChatEncryption.encrypt_message(sharedKey, Bytes.of_string(message)).then(function (response) {
          messageData["message"] = response[1];
          messageData["nonce"] = response[0];
          if (socket !== undefined) {
            Caml_option.valFromOption(socket).send(JSON.stringify(messageData));
            console.log("Sent encrypted message");
            setMessages(function (prev) {
                  var newMessage = {
                    msg_type: "PrivateChat",
                    from: currentUser,
                    to_: selectedUser,
                    message: message,
                    timestamp: timestamp
                  };
                  return Belt_Array.concat(prev, [newMessage]);
                });
          }
          return Promise.resolve();
        });
  };
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsxs("div", {
                    children: [
                      JsxRuntime.jsxs("div", {
                            children: [
                              JsxRuntime.jsx("h2", {
                                    children: "Available Users",
                                    className: "text-xl font-semibold text-gray-700 mb-4 px-4 py-2 bg-blue-100 rounded-t-lg border-b border-gray-200"
                                  }),
                              JsxRuntime.jsx("ul", {
                                    children: availableUsers.length !== 0 ? Belt_Array.mapWithIndex(availableUsers, (function (idx, user) {
                                              var count = Js_dict.get(unreadMessages, user);
                                              return JsxRuntime.jsxs("li", {
                                                          children: [
                                                            JsxRuntime.jsx("span", {
                                                                  children: user,
                                                                  className: "truncate"
                                                                }),
                                                            count !== undefined ? JsxRuntime.jsx("span", {
                                                                    children: String(count),
                                                                    className: "bg-red-500 text-white text-xs rounded-full w-6 h-6 flex items-center justify-center"
                                                                  }) : null
                                                          ],
                                                          className: "flex items-center justify-between px-4 py-2 cursor-pointer hover:bg-blue-50 " + (
                                                            Caml_obj.equal(selectedUser, user) ? "bg-blue-200 font-semibold" : ""
                                                          ),
                                                          onClick: (function (param) {
                                                              var match = Js_dict.get(sharedKeysRef.current, user);
                                                              if (match === undefined) {
                                                                if (socket !== undefined) {
                                                                  console.log("Requesting public key for user : " + user);
                                                                  getPublicKey(user);
                                                                  return setSelectedUser(function (param) {
                                                                              return user;
                                                                            });
                                                                } else {
                                                                  console.log("WebSocket not connected");
                                                                  return ;
                                                                }
                                                              }
                                                              var newUnreadMessages = Js_dict.fromArray(Belt_Array.map(Js_dict.entries(unreadMessages), (function (param) {
                                                                          return [
                                                                                  param[0],
                                                                                  String(param[1])
                                                                                ];
                                                                        })));
                                                              Js_dict.unsafeDeleteKey(newUnreadMessages, user);
                                                              setUnreadMessages(function (param) {
                                                                    return Js_dict.fromArray(Belt_Array.map(Js_dict.entries(newUnreadMessages), (function (param) {
                                                                                      return [
                                                                                              param[0],
                                                                                              Belt_Option.getExn(Belt_Int.fromString(param[1]))
                                                                                            ];
                                                                                    })));
                                                                  });
                                                              setSelectedUser(function (param) {
                                                                    return user;
                                                                  });
                                                            })
                                                        }, String(idx));
                                            })) : JsxRuntime.jsx("li", {
                                            children: "No other users online",
                                            className: "text-gray-500 text-center px-4 py-2"
                                          }),
                                    className: "flex-1 overflow-y-auto"
                                  })
                            ],
                            className: "w-1/4 pr-4 flex flex-col bg-white rounded-lg shadow-md"
                          }),
                      JsxRuntime.jsx("div", {
                            children: selectedUser !== undefined ? JsxRuntime.jsxs(JsxRuntime.Fragment, {
                                    children: [
                                      JsxRuntime.jsx("div", {
                                            children: "Chat with " + selectedUser,
                                            className: "text-xl font-semibold text-gray-700 px-4 py-2 bg-blue-100 rounded-t-lg border-b border-gray-200"
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: messages.length !== 0 ? Belt_Array.mapWithIndex(Belt_Array.keepMap(messages, (function (msg) {
                                                          var match = msg.msg_type;
                                                          if (selectedUser !== undefined && match === "PrivateChat" && (msg.from === selectedUser && Caml_obj.equal(msg.to_, currentUser) || msg.from === currentUser && Caml_obj.equal(msg.to_, selectedUser))) {
                                                            return msg;
                                                          }
                                                          
                                                        })), (function (idx, msg) {
                                                      return JsxRuntime.jsxs("div", {
                                                                  children: [
                                                                    JsxRuntime.jsx("div", {
                                                                          children: msg.from + ":",
                                                                          className: "font-medium text-blue-600"
                                                                        }),
                                                                    JsxRuntime.jsx("div", {
                                                                          children: msg.message,
                                                                          className: "text-gray-800"
                                                                        }),
                                                                    JsxRuntime.jsx("div", {
                                                                          children: formatTimestamp(msg.timestamp),
                                                                          className: "text-xs text-gray-500 mt-1"
                                                                        })
                                                                  ],
                                                                  className: "mb-4 p-3 rounded-lg " + (
                                                                    msg.from === currentUser ? "bg-blue-50 self-end text-right" : "bg-gray-100 self-start text-left"
                                                                  )
                                                                }, String(idx));
                                                    })) : JsxRuntime.jsx("p", {
                                                    children: "No messages yet!",
                                                    className: "text-gray-500 text-center mt-4"
                                                  }),
                                            className: "flex-1 overflow-y-auto p-4"
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: JsxRuntime.jsx(ChatInput.make, {
                                                  onSubmit: handleSendMessage
                                                }),
                                            className: "p-4 border-t border-gray-200"
                                          })
                                    ]
                                  }) : JsxRuntime.jsx("div", {
                                    children: JsxRuntime.jsx("div", {
                                          children: "Pick a user to chat with",
                                          className: "text-lg font-bold text-gray-500"
                                        }),
                                    className: "flex items-center justify-center flex-1"
                                  }),
                            className: "w-3/4 flex flex-col bg-white rounded-lg shadow-md"
                          })
                    ],
                    className: "flex h-full"
                  }),
              className: "p-6 bg-gradient-to-r from-blue-200 to-slate-300 w-full h-full flex flex-col rounded-lg shadow-lg"
            });
}

var make = ChatBox;

export {
  make ,
}
/* react Not a pure module */
