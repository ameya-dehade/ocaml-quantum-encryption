// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Random from "rescript/lib/es6/random.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_bytes from "rescript/lib/es6/caml_bytes.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Core__List from "@rescript/core/src/Core__List.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

var Kyber512_Config = {
  q: 3329,
  n: 256,
  k: 2,
  n1: 3,
  n2: 2
};

var Kyber768_Config = {
  q: 3329,
  n: 256,
  k: 3,
  n1: 2,
  n2: 2
};

var Kyber1024_Config = {
  q: 3329,
  n: 256,
  k: 4,
  n1: 2,
  n2: 2
};

var Test_Kyber_Config_Mini = {
  q: 17,
  n: 4,
  k: 2,
  n1: 3,
  n2: 2
};

function Make_polynomial(C) {
  Random.self_init();
  var modulus_q = C.q;
  var modulus_poly = Core__List.fromInitializer(C.n + 1 | 0, (function (i) {
          if (i === 0 || i === C.n) {
            return 1;
          } else {
            return 0;
          }
        }));
  var padding = function (p1, p2) {
    var len1 = Core__List.length(p1);
    var len2 = Core__List.length(p2);
    if (len1 > len2) {
      return [
              p1,
              Core__List.concat(Core__List.make(len1 - len2 | 0, 0), p2)
            ];
    } else if (len1 < len2) {
      return [
              Core__List.concat(Core__List.make(len2 - len1 | 0, 0), p1),
              p2
            ];
    } else {
      return [
              p1,
              p2
            ];
    }
  };
  var add = function (p1, p2) {
    var match = padding(p1, p2);
    return Core__List.zipBy(match[0], match[1], (function (x, y) {
                  return x + y | 0;
                }));
  };
  var sub = function (p1, p2) {
    var match = padding(p1, p2);
    return Core__List.zipBy(match[0], match[1], (function (x, y) {
                  return x - y | 0;
                }));
  };
  var scalar_mul = function (scalar, p) {
    return Core__List.map(p, (function (coef) {
                  return Math.imul(scalar, coef);
                }));
  };
  var scalar_div = function (scalar, p) {
    return Core__List.map(p, (function (coef) {
                  return Caml_int32.div(coef, scalar);
                }));
  };
  var mul = function (p1, p2) {
    var front_add = function (a, b) {
      if (a) {
        if (b) {
          return {
                  hd: a.hd + b.hd | 0,
                  tl: front_add(a.tl, b.tl)
                };
        } else {
          return a;
        }
      } else {
        return b;
      }
    };
    var _acc = /* [] */0;
    var _p = p1;
    var _d = 0;
    while(true) {
      var d = _d;
      var p = _p;
      var acc = _acc;
      if (!p) {
        return acc;
      }
      var x = p.hd;
      var shifted = Core__List.concat(Core__List.make(d, 0), Core__List.map(p2, (function(x){
              return function (c) {
                return Math.imul(x, c);
              }
              }(x))));
      _d = d + 1 | 0;
      _p = p.tl;
      _acc = front_add(acc, shifted);
      continue ;
    };
  };
  var reduce = function (p) {
    var poly_mod = function (_p, m) {
      while(true) {
        var p = _p;
        var degree_p = Core__List.length(p) - 1 | 0;
        var degree_m = Core__List.length(m) - 1 | 0;
        if (degree_p < degree_m) {
          return p;
        }
        var lead_coeff = Core__List.headExn(p);
        var scaled_modulus = Core__List.map(Core__List.concat(m, Core__List.make(degree_p - degree_m | 0, 0)), (function(lead_coeff){
            return function (coef) {
              return Math.imul(coef, lead_coeff);
            }
            }(lead_coeff)));
        var reduced = sub(p, scaled_modulus);
        _p = Core__List.tailExn(reduced);
        continue ;
      };
    };
    var mod_coeffs = poly_mod(p, modulus_poly);
    return Core__List.map(mod_coeffs, (function (coef) {
                  return Caml_int32.mod_(Caml_int32.mod_(coef, modulus_q) + modulus_q | 0, modulus_q);
                }));
  };
  var add_and_reduce = function (p1, p2) {
    return reduce(add(p1, p2));
  };
  var sub_and_reduce = function (p1, p2) {
    return reduce(sub(p1, p2));
  };
  var mul_and_reduce = function (p1, p2) {
    return reduce(mul(p1, p2));
  };
  var round = function (p) {
    var round_to_q_or_0 = function (coeff) {
      var q_over_2 = (modulus_q + 1 | 0) / 2 | 0;
      var delta = q_over_2 / 2 | 0;
      if (PervasivesU.abs(coeff - q_over_2 | 0) < delta) {
        return q_over_2;
      } else {
        return 0;
      }
    };
    return Core__List.map(p, round_to_q_or_0);
  };
  var binary_to_poly = function (message) {
    var byte_to_bits = function ($$byte) {
      return Core__List.fromInitializer(8, (function (i) {
                    if (($$byte & (1 << (7 - i | 0))) !== 0) {
                      return 1;
                    } else {
                      return 0;
                    }
                  }));
    };
    var bytes_list = Core__List.fromInitializer(message.length, (function (i) {
            return Caml_bytes.get(message, i);
          }));
    return Belt_List.flatten(Core__List.map(bytes_list, byte_to_bits));
  };
  var poly_to_binary = function (poly) {
    var bits_to_byte = function (bits) {
      return PervasivesU.char_of_int(Core__List.reduceWithIndex(bits, 0, (function (acc, bit, i) {
                        if (bit === 1) {
                          return acc + (1 << (7 - i | 0)) | 0;
                        } else {
                          return acc;
                        }
                      })));
    };
    var remainder = Core__List.length(poly) % 8;
    var padded_bits = remainder === 0 ? poly : Core__List.concat(poly, Core__List.make(8 - remainder | 0, 0));
    var num_bytes = Core__List.length(padded_bits) / 8 | 0;
    var bytes = Caml_bytes.create(num_bytes);
    var chunk_func = function (list, size) {
      if (Core__List.length(list) <= size) {
        return [list];
      }
      var match = Core__List.splitAt(list, size);
      if (match !== undefined) {
        return Belt_Array.concatMany([
                    [match[0]],
                    chunk_func(match[1], size)
                  ]);
      } else {
        return [];
      }
    };
    var chunks = chunk_func(padded_bits, 8);
    var chunks_list = Belt_List.fromArray(chunks);
    Core__List.forEachWithIndex(chunks_list, (function (chunk, i) {
            Caml_bytes.set(bytes, i, bits_to_byte(chunk));
          }));
    return bytes;
  };
  var from_coefficients = function (coeffs) {
    return coeffs;
  };
  var to_coefficients = function (p) {
    return p;
  };
  var to_string = function (p) {
    return Core__List.toArray(Core__List.map(p, (function (x) {
                        return x.toString();
                      }))).join(" ");
  };
  var from_string = function (s) {
    return Belt_List.fromArray(Belt_Array.map(s.split(" "), (function (str) {
                      var n = Core__Int.fromString(str, undefined);
                      if (n !== undefined) {
                        return n;
                      } else {
                        return -9999;
                      }
                    })));
  };
  var random = function (param) {
    return Core__List.fromInitializer(C.n, (function (param) {
                  return Random.$$int(modulus_q);
                }));
  };
  var random_small_coeff = function (eta) {
    var cbd_sample = function (eta) {
      var _eta = eta;
      var _acc = 0;
      while(true) {
        var acc = _acc;
        var eta$1 = _eta;
        if (eta$1 === 0) {
          return acc;
        }
        var a = Random.$$int(2);
        var b = Random.$$int(2);
        _acc = (acc + a | 0) - b | 0;
        _eta = eta$1 - 1 | 0;
        continue ;
      };
    };
    var _n = C.n;
    var _acc = /* [] */0;
    while(true) {
      var acc = _acc;
      var n = _n;
      if (n < 0) {
        return acc;
      }
      _acc = {
        hd: cbd_sample(eta),
        tl: acc
      };
      _n = n - 1 | 0;
      continue ;
    };
  };
  return {
          modulus_q: modulus_q,
          modulus_poly: modulus_poly,
          zero: /* [] */0,
          add: add,
          sub: sub,
          mul: mul,
          scalar_mul: scalar_mul,
          scalar_div: scalar_div,
          reduce: reduce,
          add_and_reduce: add_and_reduce,
          sub_and_reduce: sub_and_reduce,
          mul_and_reduce: mul_and_reduce,
          round: round,
          binary_to_poly: binary_to_poly,
          poly_to_binary: poly_to_binary,
          from_coefficients: from_coefficients,
          to_coefficients: to_coefficients,
          to_string: to_string,
          from_string: from_string,
          random: random,
          random_small_coeff: random_small_coeff
        };
}

function Make_poly_mat(P) {
  var zero = function (rows, cols) {
    return Core__List.make(rows, Core__List.make(cols, P.zero));
  };
  var scalar_mul = function (scalar, mat) {
    return Core__List.map(mat, (function (row) {
                  return Core__List.map(row, (function (poly) {
                                return P.scalar_mul(scalar, poly);
                              }));
                }));
  };
  var add = function (m1, m2) {
    return Core__List.zipBy(m1, m2, (function (row1, row2) {
                  return Core__List.zipBy(row1, row2, P.add_and_reduce);
                }));
  };
  var sub = function (m1, m2) {
    return Core__List.zipBy(m1, m2, (function (row1, row2) {
                  return Core__List.zipBy(row1, row2, P.sub_and_reduce);
                }));
  };
  var scalar_div = function (scalar, mat) {
    return Core__List.map(mat, (function (row) {
                  return Core__List.map(row, (function (poly) {
                                return P.scalar_div(scalar, poly);
                              }));
                }));
  };
  var transpose = function (mat) {
    return Core__List.fromInitializer(Core__List.length(Core__List.headExn(mat)), (function (i) {
                  return Core__List.fromInitializer(Core__List.length(mat), (function (j) {
                                return Core__List.getExn(Core__List.getExn(mat, j), i);
                              }));
                }));
  };
  var dot_product = function (row, col) {
    return P.reduce(Core__List.reduce2(row, col, P.zero, (function (acc, p1, p2) {
                      return P.add(acc, P.mul(p1, p2));
                    })));
  };
  var mul = function (m1, m2) {
    return Core__List.fromInitializer(Core__List.length(m1), (function (i) {
                  return Core__List.fromInitializer(Core__List.length(Core__List.headExn(m2)), (function (j) {
                                return dot_product(Core__List.getExn(m1, i), Core__List.getExn(transpose(m2), j));
                              }));
                }));
  };
  var reduce_matrix = function (mat) {
    return Core__List.map(mat, (function (row) {
                  return Core__List.map(row, (function (poly) {
                                return P.reduce(poly);
                              }));
                }));
  };
  var random = function (rows, cols) {
    return Core__List.make(rows, Core__List.make(cols, P.random()));
  };
  var random_small_coeff = function (rows, cols, eta) {
    return Core__List.make(rows, Core__List.make(cols, P.random_small_coeff(eta)));
  };
  var get_poly = function (mat, i, j) {
    return Core__List.getExn(Core__List.getExn(mat, i), j);
  };
  var set_poly = function (mat, i, j, poly) {
    return Core__List.mapWithIndex(mat, (function (row, row_index) {
                  return Core__List.mapWithIndex(row, (function (p, col_index) {
                                if (row_index === i && col_index === j) {
                                  return poly;
                                } else {
                                  return p;
                                }
                              }));
                }));
  };
  var map_poly = function (f, mat) {
    return Core__List.map(mat, (function (row) {
                  return Core__List.map(row, (function (poly) {
                                return f(poly);
                              }));
                }));
  };
  var to_list = function (mat) {
    return mat;
  };
  var from_list = function (mat) {
    return mat;
  };
  var dimensions = function (mat) {
    return [
            Core__List.length(mat),
            Core__List.length(Core__List.headExn(mat))
          ];
  };
  var to_string = function (mat) {
    if (mat) {
      return Belt_List.toArray(Core__List.map(mat, (function (row) {
                          return Belt_List.toArray(Core__List.map(row, P.to_string)).join(",");
                        }))).join("\n");
    } else {
      return "";
    }
  };
  var from_string = function (s) {
    var rows = Core__List.fromArray(s.split("\n"));
    return Core__List.map(rows, (function (row) {
                  var poly_strs = Core__List.fromArray(row.split(","));
                  return Core__List.map(poly_strs, P.from_string);
                }));
  };
  return {
          zero: zero,
          scalar_mul: scalar_mul,
          add: add,
          sub: sub,
          scalar_div: scalar_div,
          transpose: transpose,
          dot_product: dot_product,
          mul: mul,
          reduce_matrix: reduce_matrix,
          random: random,
          random_small_coeff: random_small_coeff,
          get_poly: get_poly,
          set_poly: set_poly,
          map_poly: map_poly,
          to_list: to_list,
          from_list: from_list,
          dimensions: dimensions,
          to_string: to_string,
          from_string: from_string
        };
}

function Make_Kyber(C) {
  Random.self_init();
  var modulus_q = C.q;
  var modulus_poly = Core__List.fromInitializer(C.n + 1 | 0, (function (i) {
          if (i === 0 || i === C.n) {
            return 1;
          } else {
            return 0;
          }
        }));
  var padding = function (p1, p2) {
    var len1 = Core__List.length(p1);
    var len2 = Core__List.length(p2);
    if (len1 > len2) {
      return [
              p1,
              Core__List.concat(Core__List.make(len1 - len2 | 0, 0), p2)
            ];
    } else if (len1 < len2) {
      return [
              Core__List.concat(Core__List.make(len2 - len1 | 0, 0), p1),
              p2
            ];
    } else {
      return [
              p1,
              p2
            ];
    }
  };
  var add = function (p1, p2) {
    var match = padding(p1, p2);
    return Core__List.zipBy(match[0], match[1], (function (x, y) {
                  return x + y | 0;
                }));
  };
  var sub = function (p1, p2) {
    var match = padding(p1, p2);
    return Core__List.zipBy(match[0], match[1], (function (x, y) {
                  return x - y | 0;
                }));
  };
  var scalar_mul = function (scalar, p) {
    return Core__List.map(p, (function (coef) {
                  return Math.imul(scalar, coef);
                }));
  };
  var scalar_div = function (scalar, p) {
    return Core__List.map(p, (function (coef) {
                  return Caml_int32.div(coef, scalar);
                }));
  };
  var mul = function (p1, p2) {
    var front_add = function (a, b) {
      if (a) {
        if (b) {
          return {
                  hd: a.hd + b.hd | 0,
                  tl: front_add(a.tl, b.tl)
                };
        } else {
          return a;
        }
      } else {
        return b;
      }
    };
    var _acc = /* [] */0;
    var _p = p1;
    var _d = 0;
    while(true) {
      var d = _d;
      var p = _p;
      var acc = _acc;
      if (!p) {
        return acc;
      }
      var x = p.hd;
      var shifted = Core__List.concat(Core__List.make(d, 0), Core__List.map(p2, (function(x){
              return function (c) {
                return Math.imul(x, c);
              }
              }(x))));
      _d = d + 1 | 0;
      _p = p.tl;
      _acc = front_add(acc, shifted);
      continue ;
    };
  };
  var reduce = function (p) {
    var poly_mod = function (_p, m) {
      while(true) {
        var p = _p;
        var degree_p = Core__List.length(p) - 1 | 0;
        var degree_m = Core__List.length(m) - 1 | 0;
        if (degree_p < degree_m) {
          return p;
        }
        var lead_coeff = Core__List.headExn(p);
        var scaled_modulus = Core__List.map(Core__List.concat(m, Core__List.make(degree_p - degree_m | 0, 0)), (function(lead_coeff){
            return function (coef) {
              return Math.imul(coef, lead_coeff);
            }
            }(lead_coeff)));
        var reduced = sub(p, scaled_modulus);
        _p = Core__List.tailExn(reduced);
        continue ;
      };
    };
    var mod_coeffs = poly_mod(p, modulus_poly);
    return Core__List.map(mod_coeffs, (function (coef) {
                  return Caml_int32.mod_(Caml_int32.mod_(coef, modulus_q) + modulus_q | 0, modulus_q);
                }));
  };
  var add_and_reduce = function (p1, p2) {
    return reduce(add(p1, p2));
  };
  var sub_and_reduce = function (p1, p2) {
    return reduce(sub(p1, p2));
  };
  var round = function (p) {
    var round_to_q_or_0 = function (coeff) {
      var q_over_2 = (modulus_q + 1 | 0) / 2 | 0;
      var delta = q_over_2 / 2 | 0;
      if (PervasivesU.abs(coeff - q_over_2 | 0) < delta) {
        return q_over_2;
      } else {
        return 0;
      }
    };
    return Core__List.map(p, round_to_q_or_0);
  };
  var binary_to_poly = function (message) {
    var byte_to_bits = function ($$byte) {
      return Core__List.fromInitializer(8, (function (i) {
                    if (($$byte & (1 << (7 - i | 0))) !== 0) {
                      return 1;
                    } else {
                      return 0;
                    }
                  }));
    };
    var bytes_list = Core__List.fromInitializer(message.length, (function (i) {
            return Caml_bytes.get(message, i);
          }));
    return Belt_List.flatten(Core__List.map(bytes_list, byte_to_bits));
  };
  var to_string = function (p) {
    return Core__List.toArray(Core__List.map(p, (function (x) {
                        return x.toString();
                      }))).join(" ");
  };
  var from_string = function (s) {
    return Belt_List.fromArray(Belt_Array.map(s.split(" "), (function (str) {
                      var n = Core__Int.fromString(str, undefined);
                      if (n !== undefined) {
                        return n;
                      } else {
                        return -9999;
                      }
                    })));
  };
  var random = function (param) {
    return Core__List.fromInitializer(C.n, (function (param) {
                  return Random.$$int(modulus_q);
                }));
  };
  var random_small_coeff = function (eta) {
    var cbd_sample = function (eta) {
      var _eta = eta;
      var _acc = 0;
      while(true) {
        var acc = _acc;
        var eta$1 = _eta;
        if (eta$1 === 0) {
          return acc;
        }
        var a = Random.$$int(2);
        var b = Random.$$int(2);
        _acc = (acc + a | 0) - b | 0;
        _eta = eta$1 - 1 | 0;
        continue ;
      };
    };
    var _n = C.n;
    var _acc = /* [] */0;
    while(true) {
      var acc = _acc;
      var n = _n;
      if (n < 0) {
        return acc;
      }
      _acc = {
        hd: cbd_sample(eta),
        tl: acc
      };
      _n = n - 1 | 0;
      continue ;
    };
  };
  var zero = function (rows, cols) {
    return Core__List.make(rows, Core__List.make(cols, /* [] */0));
  };
  var add$1 = function (m1, m2) {
    return Core__List.zipBy(m1, m2, (function (row1, row2) {
                  return Core__List.zipBy(row1, row2, add_and_reduce);
                }));
  };
  var sub$1 = function (m1, m2) {
    return Core__List.zipBy(m1, m2, (function (row1, row2) {
                  return Core__List.zipBy(row1, row2, sub_and_reduce);
                }));
  };
  var transpose = function (mat) {
    return Core__List.fromInitializer(Core__List.length(Core__List.headExn(mat)), (function (i) {
                  return Core__List.fromInitializer(Core__List.length(mat), (function (j) {
                                return Core__List.getExn(Core__List.getExn(mat, j), i);
                              }));
                }));
  };
  var mul$1 = function (m1, m2) {
    return Core__List.fromInitializer(Core__List.length(m1), (function (i) {
                  return Core__List.fromInitializer(Core__List.length(Core__List.headExn(m2)), (function (j) {
                                var row = Core__List.getExn(m1, i);
                                var col = Core__List.getExn(transpose(m2), j);
                                return reduce(Core__List.reduce2(row, col, /* [] */0, (function (acc, p1, p2) {
                                                  return add(acc, mul(p1, p2));
                                                })));
                              }));
                }));
  };
  var reduce_matrix = function (mat) {
    return Core__List.map(mat, (function (row) {
                  return Core__List.map(row, (function (poly) {
                                return reduce(poly);
                              }));
                }));
  };
  var random$1 = function (rows, cols) {
    return Core__List.make(rows, Core__List.make(cols, random()));
  };
  var random_small_coeff$1 = function (rows, cols, eta) {
    return Core__List.make(rows, Core__List.make(cols, random_small_coeff(eta)));
  };
  var get_poly = function (mat, i, j) {
    return Core__List.getExn(Core__List.getExn(mat, i), j);
  };
  var set_poly = function (mat, i, j, poly) {
    return Core__List.mapWithIndex(mat, (function (row, row_index) {
                  return Core__List.mapWithIndex(row, (function (p, col_index) {
                                if (row_index === i && col_index === j) {
                                  return poly;
                                } else {
                                  return p;
                                }
                              }));
                }));
  };
  var to_string$1 = function (mat) {
    if (mat) {
      return Belt_List.toArray(Core__List.map(mat, (function (row) {
                          return Belt_List.toArray(Core__List.map(row, to_string)).join(",");
                        }))).join("\n");
    } else {
      return "";
    }
  };
  var from_string$1 = function (s) {
    var rows = Core__List.fromArray(s.split("\n"));
    return Core__List.map(rows, (function (row) {
                  var poly_strs = Core__List.fromArray(row.split(","));
                  return Core__List.map(poly_strs, from_string);
                }));
  };
  var q = C.q;
  var k = C.k;
  var n1 = C.n1;
  var n2 = C.n2;
  var public_key_to_string = function (pub_key) {
    var a = to_string$1(pub_key[0]);
    var t = to_string$1(pub_key[1]);
    return a + ("|" + t);
  };
  var private_key_to_string = function (priv_key) {
    return to_string$1(priv_key);
  };
  var ciphertext_to_string = function (cipher) {
    var u = to_string$1(cipher[0]);
    var v = to_string$1(cipher[1]);
    return u + ("|" + v);
  };
  var public_key_from_string = function (s) {
    var split = Core__List.fromArray(s.split("|"));
    var a = from_string$1(Core__List.getExn(split, 0));
    var t = from_string$1(Core__List.getExn(split, 1));
    return [
            a,
            t
          ];
  };
  var private_key_from_string = function (s) {
    return from_string$1(s);
  };
  var ciphertext_from_string = function (s) {
    var split = Core__List.fromArray(s.split("|"));
    var u = from_string$1(Core__List.getExn(split, 0));
    var v = from_string$1(Core__List.getExn(split, 1));
    return [
            u,
            v
          ];
  };
  var generate_keypair = function (param) {
    var priv_key = random_small_coeff$1(k, 1, n1);
    var a = reduce_matrix(random$1(k, k));
    var error = reduce_matrix(random_small_coeff$1(k, 1, n1));
    var t = reduce_matrix(add$1(mul$1(a, priv_key), error));
    var pub_key = [
      a,
      t
    ];
    return [
            public_key_to_string(pub_key),
            to_string$1(priv_key)
          ];
  };
  var encrypt = function (pub_key, message) {
    var pub_key$1 = public_key_from_string(pub_key);
    var calculate_u = function (a, r, e1) {
      var a_transpose = transpose(a);
      var mul_r = mul$1(a_transpose, r);
      return add$1(mul_r, e1);
    };
    var calculate_v = function (t, r, e2, scaled_msg) {
      var t_transpose = transpose(t);
      var mul_r = mul$1(t_transpose, r);
      var add_e2 = add$1(mul_r, e2);
      return add$1(add_e2, scaled_msg);
    };
    var r = reduce_matrix(random_small_coeff$1(k, 1, n1));
    var e1 = reduce_matrix(random_small_coeff$1(k, 1, n2));
    var e2 = reduce_matrix(random_small_coeff$1(1, 1, n2));
    var scaled_msg = scalar_mul((q + 1 | 0) / 2 | 0, binary_to_poly(message));
    var zero_mat = zero(1, 1);
    var scaled_msg_mat = set_poly(zero_mat, 0, 0, scaled_msg);
    var u = calculate_u(pub_key$1[0], r, e1);
    var v = calculate_v(pub_key$1[1], r, e2, scaled_msg_mat);
    return ciphertext_to_string([
                u,
                v
              ]);
  };
  var decrypt = function (s, cipher) {
    var s$1 = from_string$1(s);
    var cipher$1 = ciphertext_from_string(cipher);
    var u = cipher$1[0];
    var v = cipher$1[1];
    var noisy_result = sub$1(v, mul$1(transpose(s$1), u));
    var noisy_poly = get_poly(noisy_result, 0, 0);
    var rounded_poly = round(noisy_poly);
    var result_poly = scalar_div((q + 1 | 0) / 2 | 0, rounded_poly);
    var bits_to_byte = function (bits) {
      return PervasivesU.char_of_int(Core__List.reduceWithIndex(bits, 0, (function (acc, bit, i) {
                        if (bit === 1) {
                          return acc + (1 << (7 - i | 0)) | 0;
                        } else {
                          return acc;
                        }
                      })));
    };
    var remainder = Core__List.length(result_poly) % 8;
    var padded_bits = remainder === 0 ? result_poly : Core__List.concat(result_poly, Core__List.make(8 - remainder | 0, 0));
    var num_bytes = Core__List.length(padded_bits) / 8 | 0;
    var bytes = Caml_bytes.create(num_bytes);
    var chunk_func = function (list, size) {
      if (Core__List.length(list) <= size) {
        return [list];
      }
      var match = Core__List.splitAt(list, size);
      if (match !== undefined) {
        return Belt_Array.concatMany([
                    [match[0]],
                    chunk_func(match[1], size)
                  ]);
      } else {
        return [];
      }
    };
    var chunks = chunk_func(padded_bits, 8);
    var chunks_list = Belt_List.fromArray(chunks);
    Core__List.forEachWithIndex(chunks_list, (function (chunk, i) {
            Caml_bytes.set(bytes, i, bits_to_byte(chunk));
          }));
    return bytes;
  };
  return {
          public_key_to_string: public_key_to_string,
          private_key_to_string: private_key_to_string,
          ciphertext_to_string: ciphertext_to_string,
          public_key_from_string: public_key_from_string,
          private_key_from_string: private_key_from_string,
          ciphertext_from_string: ciphertext_from_string,
          generate_keypair: generate_keypair,
          encrypt: encrypt,
          decrypt: decrypt
        };
}

export {
  Kyber512_Config ,
  Kyber768_Config ,
  Kyber1024_Config ,
  Test_Kyber_Config_Mini ,
  Make_polynomial ,
  Make_poly_mat ,
  Make_Kyber ,
}
/* No side effect */
