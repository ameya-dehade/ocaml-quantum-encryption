// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Char from "rescript/lib/es6/char.js";
import * as Bytes from "rescript/lib/es6/bytes.js";
import * as Kyber from "./kyber.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Caml_bytes from "rescript/lib/es6/caml_bytes.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var algo = "AES-GCM";

var algorithm = {
  name: "AES-GCM",
  length: 256
};

var keyUsages = [
  "encrypt",
  "decrypt"
];

var format = "raw";

function arrayBufferToBytes(arrayBuffer) {
  var uint8Array = new Uint8Array(arrayBuffer);
  var bytesLength = uint8Array.byteLength;
  var bytes = Caml_bytes.create(bytesLength);
  for(var i = 0; i < bytesLength; ++i){
    var intValue = uint8Array[i];
    Caml_bytes.set(bytes, i, Char.chr(intValue));
  }
  return bytes;
}

function bytesToArrayBuffer(bytes) {
  var bytesLength = bytes.length;
  var uint8Array = new Uint8Array(bytesLength);
  for(var i = 0; i < bytesLength; ++i){
    var $$byte = Caml_bytes.get(bytes, i);
    uint8Array[i] = $$byte;
  }
  return uint8Array.buffer;
}

var KyberKEM = Kyber.Make_Kyber(Kyber.Kyber768_Config);

async function generateSharedKey() {
  try {
    var keyObject = await window.crypto.subtle.generateKey(algorithm, true, keyUsages);
    return await window.crypto.subtle.exportKey(format, keyObject);
  }
  catch (exn){
    return Js_exn.raiseError("Failed to generate key");
  }
}

function generate_keypair_for_new_user() {
  return KyberKEM.generate_keypair();
}

function decrypt_recieved_shared_key(my_priv_key, cipher) {
  console.log("Received private key in function: ", my_priv_key);
  console.log("Received cipher in function: ", cipher);
  return KyberKEM.decrypt(my_priv_key, cipher);
}

async function generate_and_encrypt_shared_key(their_pub_key) {
  var sharedKey = await generateSharedKey();
  var bytes_val = arrayBufferToBytes(sharedKey);
  var encryptedSharedKey = KyberKEM.encrypt(their_pub_key, bytes_val);
  return {
          sharedKey: bytes_val,
          encryptedSharedKey: encryptedSharedKey
        };
}

async function create_crypto_key(shared_key) {
  var shared_key_bytes = Bytes.of_string(shared_key);
  var shared_key_raw = bytesToArrayBuffer(shared_key_bytes);
  return await window.crypto.subtle.importKey(format, shared_key_raw, algorithm, true, keyUsages);
}

async function encrypt_message(shared_key, message) {
  console.log("Encrypting message with shared key: ", shared_key);
  console.log("Message to encrypt: ", message);
  try {
    var shared_crypto_key = await create_crypto_key(shared_key);
    var nonce = window.crypto.getRandomValues(new Uint8Array(12));
    var algorithm_obj = {
      name: algo,
      iv: nonce
    };
    var nonce_string = Bytes.to_string(arrayBufferToBytes(nonce.buffer));
    var encrypted = await window.crypto.subtle.encrypt(algorithm_obj, shared_crypto_key, bytesToArrayBuffer(message));
    var encrypted_string = Bytes.to_string(arrayBufferToBytes(encrypted));
    return [
            nonce_string,
            encrypted_string
          ];
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    console.error("Failed to encrypt message: " + err);
    return Js_exn.raiseError("Failed to encrypt message");
  }
}

async function decrypt_message(shared_key, nonce, cipher) {
  console.log("Decrypting message with shared key in function: ", shared_key);
  console.log("Nonce in function: ", nonce);
  console.log("Cipher in function: ", cipher);
  try {
    var shared_crypto_key = await create_crypto_key(shared_key);
    var nonce_array = bytesToArrayBuffer(Bytes.of_string(nonce));
    var algorithm_obj = {
      name: algo,
      iv: nonce_array
    };
    var decrypted = await window.crypto.subtle.decrypt(algorithm_obj, shared_crypto_key, bytesToArrayBuffer(Bytes.of_string(cipher)));
    return arrayBufferToBytes(decrypted);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    console.error("Failed to encrypt message: " + err);
    return Js_exn.raiseError("Failed to encrypt message");
  }
}

export {
  algo ,
  algorithm ,
  keyUsages ,
  format ,
  arrayBufferToBytes ,
  bytesToArrayBuffer ,
  KyberKEM ,
  generateSharedKey ,
  generate_keypair_for_new_user ,
  decrypt_recieved_shared_key ,
  generate_and_encrypt_shared_key ,
  create_crypto_key ,
  encrypt_message ,
  decrypt_message ,
}
/* KyberKEM Not a pure module */
